local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

if not hookfunction or not hookmetamethod or not getrawmetatable then
    LocalPlayer:Kick("Executor not supported.")
end

if getgenv().velithraloaded then return end
getgenv().velithraloaded = true

for _, v in getconnections(game:GetService("ScriptContext").Error) do
    v:Disable()
end
local Name = LocalPlayer.Name
local Userid = LocalPlayer.UserId

local function detectExecutor()
    local executor = (syn and not is_sirhurt_closure and not pebc_execute and "Synapse X")
        or (secure_load and "Sentinel")
        or (pebc_execute and "ProtoSmasher")
        or (KRNL_LOADED and "Krnl")
        or (is_sirhurt_closure and "SirHurt")
        or (identifyexecutor():find("ScriptWare") and "Script-Ware")
        or identifyexecutor()
    return executor
end

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/WetCheezit/UI-Libs/main/Exodus.lua"))()
local window = library:Load{playerlist = true}
local watermark = library:Watermark("aftemath.vip | Aftermath | V1")

window:SettingsTab(watermark)
local tab = window:Tab("Combat")
local tab2 = window:Tab("Visuals")
local tab3 = window:Tab("Items Visuals")
local tab4 = window:Tab("Rage")

-- ...rest of your script (all features, UI, etc.)...

library:Init()
-----------------------------------------BYPASS-------------------------------------------------------------------------
for i, v in pairs(getgc(true)) do
    if type(v) == 'table' then
        if not getrawmetatable(v) then
            local Encrypt = rawget(v, 'encrypt')
            if Encrypt and rawget(v, 'gf') and rawget(v, 'buffer') then
                if typeof(Encrypt) == 'function' then
                    hookfunction(Encrypt, LPH_NO_UPVALUES(function(...)
                        return task.wait(9e9)
                    end))
                    break
                end
            end
        end
    end
end
-----------------------------------------PLAYER ESP---------------------------------------------------------------------
local sec1 = tab:Section{
    Side = "Left",
    Name = "Aimbot"
}


local UserInputService = game:GetService("UserInputService")
local localPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera

GRAVITY = 50
enabled = false
showFOV = false
showSnapline = false
fovRadius = 200
fovThickness = 2
snaplineThickness = 2
smoothing = 0.5
fovColor = Color3.fromRGB(255, 255, 255)
snaplineColor = Color3.fromRGB(255, 0, 0)
fovRainbow = false
snaplineRainbow = false
keybind = Enum.KeyCode.E
aiming = false
snapline = nil

predictionXAdjust = 1
predictionYAdjust = 1

local fovCircle = Drawing.new("Circle")
fovCircle.Radius = fovRadius
fovCircle.Thickness = fovThickness
fovCircle.NumSides = 64
fovCircle.Color = fovColor
fovCircle.Transparency = 1
fovCircle.Filled = false
fovCircle.Visible = showFOV

sec1:Toggle{
    name = "Enable Aimbot",
    default = false,
    callback = function(v) enabled = v end
}
sec1:Toggle{
    name = "Show FOV Circle",
    default = false,
    callback = function(v) showFOV = v end
}
sec1:Toggle{
    name = "Show Snapline",
    default = false,
    callback = function(v) showSnapline = v end
}
sec1:Slider{
    name = "FOV Radius",
    min = 0,
    max = 500,
    default = 200,
    callback = function(v)
        fovRadius = v
        fovCircle.Radius = v
    end
}
sec1:Slider{
    name = "FOV Outline Thickness",
    min = 0,
    max = 100,
    default = 2,
    callback = function(v)
        fovThickness = v
        fovCircle.Thickness = v
    end
}
sec1:Slider{
    name = "Snapline Thickness",
    min = 0,
    max = 100,
    default = 2,
    callback = function(v)
        snaplineThickness = v
    end
}
sec1:Slider{
    name = "Aimbot Smoothing",
    min = 0,
    max = 100,
    default = 100,
    callback = function(v)
        smoothing = math.clamp(v / 100, 0.01, 1)
    end
}
sec1:Colorpicker{
    name = "FOV Circle Color",
    default = Color3.fromRGB(255, 255, 255),
    callback = function(c)
        fovColor = c
        fovCircle.Color = c
    end
}
local teamCheck = true
sec1:Toggle{
    name = "Ignore Teammates",
    default = true,
    callback = function(v) teamCheck = v end
}

sec1:Toggle{
    name = "FOV Rainbow Effect",
    default = false,
    callback = function(v) fovRainbow = v end
}
sec1:Colorpicker{
    name = "Snapline Color",
    default = Color3.fromRGB(255, 0, 0),
    callback = function(c)
        snaplineColor = c
    end
}
sec1:Toggle{
    name = "Snapline Rainbow Effect",
    default = false,
    callback = function(v) snaplineRainbow = v end
}
sec1:Keybind{
    name = "Aimbot Key",
    default = Enum.KeyCode.E,
    callback = function(k)
        keybind = k
    end
}
sec1:Slider{
    name = "Prediction X Adjustment",
    min = 0,
    max = 200,
    default = 100,
    callback = function(v)
        predictionXAdjust = v / 100
    end
}
sec1:Slider{
    name = "Prediction Y Adjustment",
    min = 0,
    max = 200,
    default = 100,
    callback = function(v)
        predictionYAdjust = v / 100
    end
}

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == keybind then
        aiming = true
    elseif input.UserInputType == Enum.UserInputType.MouseButton1 and keybind == Enum.UserInputType.MouseButton1 then
        aiming = true
    elseif input.UserInputType == Enum.UserInputType.MouseButton2 and keybind == Enum.UserInputType.MouseButton2 then
        aiming = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == keybind then
        aiming = false
    elseif input.UserInputType == Enum.UserInputType.MouseButton1 and keybind == Enum.UserInputType.MouseButton1 then
        aiming = false
    elseif input.UserInputType == Enum.UserInputType.MouseButton2 and keybind == Enum.UserInputType.MouseButton2 then
        aiming = false
    end
end)

local function worldToScreen(pos)
    local pt, onScreen = camera:WorldToViewportPoint(pos)
    return Vector2.new(pt.X, pt.Y), onScreen
end

local function getEquippedBulletSpeed()
    local sel = localPlayer.CurrentSelectedObject and localPlayer.CurrentSelectedObject.Value
    if typeof(sel) ~= "Instance" then return 2200 end

    local slot = localPlayer.GunInventory:FindFirstChild(sel.Name)
    if not slot or not slot.Value then return 2200 end

    local gunName
    if typeof(slot.Value) == "string" then
        gunName = slot.Value
    elseif typeof(slot.Value) == "Instance" then
        gunName = tostring(slot.Value)
    else
        return 2250
    end

    local data = ReplicatedStorage.GunData:FindFirstChild(gunName)
    if not data or not data:FindFirstChild("Stats") or not data.Stats:FindFirstChild("BulletSettings") then return 2200 end

    local spd = data.Stats.BulletSettings:FindFirstChild("BulletSpeed")
    return (spd and spd:IsA("IntValue")) and spd.Value or 2200
end


local function calculateDrop(distance, speed)
    if not speed or speed <= 0 then return 0 end
    local t = distance / speed
    return 0.5 * GRAVITY * t * t
end

local lastRun = 0
RunService.RenderStepped:Connect(function()
    if tick() - lastRun < 0.03 then return end -- ~30 FPS cap
    lastRun = tick()
    local center2d = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    fovCircle.Position = center2d
    fovCircle.Visible = showFOV
    fovCircle.Color = fovRainbow and Color3.fromHSV(tick() % 5 / 5, 1, 1) or fovColor

    local heads = {} -- <--- FIX: clear heads every frame!
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Head") then
            table.insert(heads, player.Character.Head)
        end
    end

    local myHead = localPlayer.Character and (localPlayer.Character:FindFirstChild("ServerColliderHead") or localPlayer.Character:FindFirstChild("Head"))
    local ignoreIdx, ignoreDist = nil, math.huge
    if myHead then
        for i, head in ipairs(heads) do
            local d = (head.Position - myHead.Position).Magnitude
            if d < ignoreDist then
                ignoreDist = d
                ignoreIdx = i
            end
        end
    end

    local targetHead, target2d, minDist = nil, nil, math.huge
    for i, head in ipairs(heads) do
        local targetPlayer = Players:GetPlayerFromCharacter(head.Parent)
        if teamCheck and targetPlayer and targetPlayer.Team == localPlayer.Team then
        continue
    end
            if i ~= ignoreIdx then
            local pos2d, onScreen = worldToScreen(head.Position)
            if onScreen then
                local dist = (pos2d - center2d).Magnitude
                if dist <= fovRadius and dist < minDist then
                    minDist = dist
                    targetHead = head
                    target2d = pos2d
                end
            end
        end
    end

if snapline == nil then
    local snapLine = Drawing.new("Line")
    snapline.Visible = false
    snapline.Color = snaplineColor
    snapline.Thickness = snaplineThickness
end




if showSnapline and targetHead then
    snapline.Visible = true
    snapline.From = center2d
    snapline.To = target2d
    snapline.Color = snaplineRainbow and Color3.fromHSV(tick() % 5 / 5, 1, 1) or snaplineColor
    snapline.Thickness = snaplineThickness
    snapline.Transparency = 1
else
    snapline.Visible = false
end


    if aiming and enabled and targetHead then
        local camPos = camera.CFrame.Position
        local headPos = targetHead.Position
        local horizDist = (Vector3.new(headPos.X, camPos.Y, headPos.Z) - camPos).Magnitude
        local speed = getEquippedBulletSpeed()
        local drop = calculateDrop(horizDist, speed) * 1.4 * predictionYAdjust

        local predictedOffset = Vector3.zero
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("ServerColliderHead") then
                local velocity = plr.Character.ServerColliderHead.Velocity
                local predictedTime = math.clamp(horizDist / speed, 0, 2)
                local prediction = velocity * predictedTime * predictionXAdjust
                if plr.Character == targetHead.Parent then
                    predictedOffset = prediction
                    break
                end
            end
        end

        local compensatedPos = headPos + Vector3.new(0, drop * 1.5, 0) + predictedOffset
        local comp2d, onS = worldToScreen(compensatedPos)
        if onS then
            local delta = comp2d - center2d
            mousemoverel(delta.X * smoothing, delta.Y * smoothing)
        end
    end
end)





local sec2 = tab:Section{
    Side = "Middle",
    Name = "Combat Visuals"
}

sec2:Button{
    name = "Instant Aim",
    callback = function()
        local patched = 0

        for _, v in next, getgc(true) do
            if type(v) == 'table' then
                for i, val in next, v do
                    if type(i) == 'string' and string.find(i:lower(), "gunaim") then
                        if type(val) == 'number' then
                            v[i] = 100000000
                            patched += 1
                        elseif type(val) == 'function' then
                            local success = pcall(function()
                                hookfunction(val, function(...) return 100000000 end)
                            end)
                            if success then
                                patched += 1
                            end
                        end
                    end
                end
            end
        end

        print("[Instant Aim] Patched:", patched)
    end
}

sec2:Button{name = "No Recoil", callback = function() 
    local spring = require(game:GetService("Players").LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("GunController"):WaitForChild("Data"):WaitForChild("Spring"))
    local velocity = spring._positionVelocity

    hookfunction(velocity, newcclosure(function(self, now)
        return self._target or Vector3.zero, Vector3.zero
    end))
end}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CameraAngleEvent = ReplicatedStorage:WaitForChild("CameraAngleEvent")

local antiAimEnabled = false
local fakePitchMax = math.rad(90)
local fakePitchMin = math.rad(-90)
local fakeYawSpeed = math.rad(20)
local currentYaw = 0
local pitchSpeed = 2

sec2:Toggle{  
    name     = "Enable Anti-Aim",  
    callback = function(enabled)  
        antiAimEnabled = enabled
    end  
}

sec2:Slider{  
    name     = "Pitch Angle Range",  
    min      = 0,  
    max      = 180,  
    default  = 90,  
    callback = function(val)  
        local radVal = math.rad(val)
        fakePitchMax = radVal
        fakePitchMin = -radVal
    end  
}

sec2:Slider{  
    name     = "Anti-Aim Speed",  
    min      = 0,  
    max      = 180,  
    default  = 90,  
    callback = function(val)  
        pitchSpeed = val
    end  
}

RunService:BindToRenderStep("CameraAngleSpoof", Enum.RenderPriority.Character.Value - 1, function(dt)
    if not antiAimEnabled then return end

    local fakePitch = fakePitchMin + math.sin(tick() * pitchSpeed) * (fakePitchMax - fakePitchMin)

    currentYaw = currentYaw + fakeYawSpeed * dt
    if currentYaw > math.pi * 2 then
        currentYaw = currentYaw - math.pi * 2
    end

    CameraAngleEvent:FireServer(fakePitch, currentYaw)
end)


local cameraFovController = require(localPlayer.PlayerScripts:WaitForChild("CameraFovController"))

local fovchanger = false

sec2:Toggle{  
    name     = "Enable Field-Of-View Adjustment",  
    callback = function(enabled)  
        if enabled then
            fovchanger = true
        else
            fovchanger = false
            cameraFovController.ClientFov = 100
        end
    end  
}

sec2:Slider{  
    name     = "Field-Of-View Adjustment Value",  
    min      = 1,  
    max      = 120,
    default  = 90,  
    callback = function(value)
        if fovchanger then
        cameraFovController.ClientFov = value
        cameraFovController:Enable()
        end
    end
}


sec2:Label("Gun Customizations")

local ReplicatedStore = game:GetService("ReplicatedStorage")

local ReticleMap = {
    ["ACOG Sight"] = "ACOG",
    ["16× Sniper Scope"] = "SniperScope16xStatic",
    ["8× Sniper Scope"] = "SniperScope8x",
    ["Red Dot Sight"] = "RedDot",
    ["Holographic Sight"] = "Holo",
    ["Reflex Sight"] = "ReflexRifle",
    ["LPVO"] = "LPVOScope",
}

local ReticleLabels = { "ACOG Sight", "16× Sniper Scope", "8× Sniper Scope", "Red Dot Sight", "Holographic Sight", "Reflex Sight", "LPVO" }
local SlotMap = { ["Slot 1"] = 1, ["Slot 2"] = 2, ["Slot 3"] = 3 }
local SlotLabels = { "Slot 1", "Slot 2", "Slot 3" }

local chosenReticle = nil
local chosenSlot = SlotLabels[1]

sec2:Dropdown{
    name = "Select Reticle",
    content = ReticleLabels,
    default = nil,
    callback = function(label)
        chosenReticle = label
    end
}

sec2:Dropdown{
    name = "Select Slot",
    content = SlotLabels,
    default = chosenSlot,
    callback = function(label)
        chosenSlot = label
    end
}

sec2:Button{
    name = "Apply Attachments",
    callback = function()
        local player = Players.LocalPlayer
        if not player then return end

        local invFolder = player:FindFirstChild("GunInventory")
        if not invFolder then return end

        local validSlots = {}
        for _, ov in ipairs(invFolder:GetChildren()) do
            if ov:IsA("ObjectValue") and ov.Value then
                table.insert(validSlots, ov)
            end
        end

        local slotIndex = SlotMap[chosenSlot]
        local slotOV = validSlots[slotIndex]
        if not slotOV then return end

        local attachments = ReplicatedStore:FindFirstChild("Assets")
        if not attachments then return end
        attachments = attachments:FindFirstChild("Attachments")
        if not attachments then return end

        local function apply(map, label, field)
            if not label then return end
            local assetName = map[label]
            if not assetName then return end
            local asset = attachments:FindFirstChild(assetName)
            if not asset then return end
            local ov = slotOV:FindFirstChild(field)
            if not ov then return end
            ov.Value = asset
        end

        apply(ReticleMap, chosenReticle, "AttachmentReticle")
    end
}

sec2:Label("Gun Offsets")

local RepStorage     = game:GetService("ReplicatedStorage")

local offsetEnabled  = false
local offsetX, offsetY, offsetZ = 2, 0, -2
local heartbeatConn
local originalOffsets = {}

local function applyOffset()
    local player = Players.LocalPlayer
    local selObj  = player.CurrentSelectedObject.Value
    if not selObj then return end

    local gunName = selObj.Name
    local invItem = player.GunInventory:FindFirstChild(gunName)
    if not (invItem and invItem.Value) then return end

    local dataFolder = RepStorage.GunData:FindFirstChild(invItem.Value.Name)
    if not dataFolder then return end

    local offsetValue = dataFolder.Stats:FindFirstChild("Offset")
    if not (offsetValue and offsetValue:IsA("Vector3Value")) then return end

    if not originalOffsets[invItem.Value.Name] then
        originalOffsets[invItem.Value.Name] = offsetValue.Value
    end

    offsetValue.Value = Vector3.new(offsetX, offsetY, offsetZ)
end

local function restoreOffsets()
    for gunName, origValue in pairs(originalOffsets) do
        local dataFolder = RepStorage.GunData:FindFirstChild(gunName)
        if dataFolder then
            local offsetValue = dataFolder.Stats:FindFirstChild("Offset")
            if offsetValue and offsetValue:IsA("Vector3Value") then
                offsetValue.Value = origValue
            end
        end
    end
    table.clear(originalOffsets)
end

sec2:Toggle{
    name    = "Enable Gun Offsets",
    default = false,
    callback = function(enabled)
        offsetEnabled = enabled

        if enabled then
            heartbeatConn = RunService.Heartbeat:Connect(applyOffset)
        else
            if heartbeatConn then
                heartbeatConn:Disconnect()
                heartbeatConn = nil
            end
            restoreOffsets()
        end
    end
}

sec2:Slider{
    name    = "X Value",
    min     = -20,
    max     =  20,
    default = offsetX,
    callback = function(val)
        offsetX = val
    end
}

sec2:Slider{
    name    = "Y Value",
    min     = -20,
    max     =  20,
    default = offsetY,
    callback = function(val)
        offsetY = val
    end
}

sec2:Slider{
    name    = "Z Value",
    min     = -20,
    max     =  20,
    default = offsetZ,
    callback = function(val)
        offsetZ = val
    end
}


local sec3 = tab:Section{
    Side = "Right",
    Name = "World & Effects"
}

local chamsEnabled    = false  
local rainbowEnabled  = false  
local baseColor       = Color3.new(1, 1, 1)  
local transparency    = 0.5  
local hbConn          = nil  
local timerAcc        = 0  
local hue             = 0  

local TARGETS = {  
    "Weapon",  
    "AttachmentMuzzle",  
    "AttachmentReticle",  
    "AttachmentUnderbarrel"  
}  

local function applyChams(model, color)  
    for _, v in ipairs(model:GetDescendants()) do  
        if v:IsA("BasePart") then  
            v.Material     = Enum.Material.ForceField  
            v.Color        = color  
            v.Transparency = transparency  
        elseif v:IsA("BlockMesh")  
           or v:IsA("SurfaceAppearance")  
           or v:IsA("Mesh") then  
            v:Destroy()  
        end  
    end  
end  

local function onHeartbeat(dt)  
    if not chamsEnabled then return end  

    local interval = rainbowEnabled and 0.5 or 5  

    timerAcc = timerAcc + dt  
    if timerAcc < interval then  
        return  
    end
    timerAcc = timerAcc - interval  
  
    local currentColor  
    if rainbowEnabled then  
        hue = (hue + dt * (1/2.5)) % 1
        currentColor = Color3.fromHSV(hue, 1, 1)  
    else  
        currentColor = baseColor  
    end  
 
    local cw = Workspace.CurrentCamera:FindFirstChild("CurrentWeapon")  
    if not cw then return end  

    for _, name in ipairs(TARGETS) do  
        local obj = cw:FindFirstChild(name)  
        if obj then  
            applyChams(obj, currentColor)  
        end  
    end  
end  

local function setLoop(active)  
    if active then  
        if not hbConn then  
            timerAcc = 0
            hue      = 0  
            hbConn   = RunService.Heartbeat:Connect(onHeartbeat)  
        end  
    else  
        if hbConn then  
            hbConn:Disconnect()  
            hbConn = nil  
        end  
    end  
end  

sec3:Toggle{  
    name     = "Enable Gun Chams",  
    callback = function(enabled)  
        chamsEnabled = enabled  
        setLoop(enabled)  
    end  
}  

sec3:Toggle{  
    name     = "Rainbow Chams",  
    callback = function(state)  
        rainbowEnabled = state  
        hue            = 0  
        timerAcc       = 0 
    end  
}  

sec3:Colorpicker{  
    name     = "Gun Chams Color",  
    default  = baseColor,  
    callback = function(c)  
        baseColor = c  
        if chamsEnabled and not rainbowEnabled then  
            timerAcc = 0
        end  
    end  
}  

sec3:Slider{  
    name     = "Gun Chams Transparency",  
    min      = 0,  
    max      = 100,  
    default  = transparency * 100,  
    callback = function(val)  
        transparency = val / 100  
        if chamsEnabled then  
            timerAcc = 0
        end  
    end  
}  

sec3:Label("Free Cam")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local rootPart = char:WaitForChild("HumanoidRootPart")

local fcActive = false
local fcCFrame = nil
local rotX, rotY = 0, 0
local fcSpeed = 1
local fcKeybind = Enum.KeyCode.F


sec3:Toggle{
    name = "Freecam", 
    callback = function(v) 
        fcToggleEnabled = v 
        if not v and fcActive then
            fcActive = false
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            UserInputService.MouseIconEnabled = true
            if rootPart then
                rootPart.Anchored = false
            end
        end
    end
}

sec3:Keybind{ 
    name = "Freecam Key", 
    default = Enum.KeyCode.F, 
    callback = function(k) 
        fcKeybind = k 
    end
}


local function getFCMovement()
    local move = Vector3.new()
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += Vector3.new(0, 0, -1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then move += Vector3.new(0, 0, 1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then move += Vector3.new(-1, 0, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += Vector3.new(1, 0, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.E) then move += Vector3.new(0, 1, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.Q) then move += Vector3.new(0, -1, 0) end
    return move.Unit == move.Unit and move.Unit or Vector3.zero
end

local function updateFCRotation(delta)
    rotX -= delta.Y * 0.002
    rotY -= delta.X * 0.002
    rotX = math.clamp(rotX, -math.pi/2, math.pi/2)
end

UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == fcKeybind then
        fcActive = not fcActive

        if fcActive then
            fcCFrame = Camera.CFrame
            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
            UserInputService.MouseIconEnabled = false
            rootPart.Anchored = true

            RunService:BindToRenderStep("UpdateFreecam", Enum.RenderPriority.Last.Value, function()
                if not fcActive then return end
                local delta = UserInputService:GetMouseDelta()
                updateFCRotation(delta)

                local moveVec = getFCMovement() * fcSpeed
                local look = CFrame.Angles(rotX, rotY, 0)
                fcCFrame += look:VectorToWorldSpace(moveVec) * fcSpeed
                Camera.CFrame = CFrame.new(fcCFrame.Position) * look
            end)
        else
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            UserInputService.MouseIconEnabled = true
            rootPart.Anchored = false
            RunService:UnbindFromRenderStep("UpdateFreecam")
        end
    end
end)

sec3:Label("Environment Settings")

local foliagetransparency = false

sec3:Toggle{
    name = "Transparent Foliage",
    callback = function(bool)
        if workspace:FindFirstChild("world_assets") then
        if bool then
            foliagetransparency = true
        else
            foliagetransparency = false
            for i, v in pairs(workspace:FindFirstChild("world_assets").StaticObjects.Trees:GetDescendants()) do
                if v.Name == "Leaves" then
                    v.Transparency = 0
                end
            end
        end
    else return end
    end
}

sec3:Slider{
    name = "Foliage Transparency",
    min = 0,
    max = 100,
    default = 50,
    callback = function(value)
        if workspace:FindFirstChild("world_assets") then
        if foliagetransparency then
            for i, v in pairs(workspace:FindFirstChild("world_assets").StaticObjects.Trees:GetDescendants()) do
                if v.Name == "Leaves" then
                    v.Transparency = value/100
                end
            end
        end
    else return end
    end
}

local lighting = game:GetService("Lighting")

local timeEnabled = false
local timeValue = 12
local timeLoopConnection = nil

local function startTimeLoop()
    if timeLoopConnection == nil then
        timeLoopConnection = runService.RenderStepped:Connect(function()
            lighting.ClockTime = timeValue
        end)
    end
end

local function stopTimeLoop()
    if timeLoopConnection then
        timeLoopConnection:Disconnect()
        timeLoopConnection = nil
    end
end

sec3:Toggle({
    name = "Time Of Day",
    def = false,
    callback = function(enabled)
        timeEnabled = enabled
        if enabled then
            startTimeLoop()
        else
            stopTimeLoop()
        end
    end
})

sec3:Slider({
    name    = "Time Of Day",
    min     = 0,
    max     = 24,
    default = 12,
    callback = function(rawValue)
        timeValue = rawValue
    end
})

local lighting   = game:GetService("Lighting")

local noFogConnection

sec3:Toggle{
    name = "No Fog",
    callback = function(enabled)
        if enabled then
            noFogConnection = runservice.RenderStepped:Connect(function()
                if lighting.Atmosphere then
                    lighting.Atmosphere.Density = 0
                end
            end)
        else
            if noFogConnection then
                noFogConnection:Disconnect()
                noFogConnection = nil
            end
        end
    end
}



sec3:Colorpicker{
    name = "Environment Tint", 
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        game:GetService("Lighting").ColorCorrection.TintColor = color
    end
}

local rainLoop

sec3:Toggle{
    name = "No Rain",
    callback = function(bool)
        if bool then
            if not rainLoop then
                rainLoop = game:GetService("RunService").RenderStepped:Connect(function()
                    for _, obj in ipairs(workspace.Terrain:GetChildren()) do
                        if obj.Name == "__RainSplash" then
                            obj:Destroy()
                        end
                    end
                end)
            end
        else
            if rainLoop then
                rainLoop:Disconnect()
                rainLoop = nil
            end
        end
    end
}

sec3:Toggle{
    name = "Remove Green Gas",
    callback = function(Boolean)
        if workspace:FindFirstChild("world_assets") then
        if Boolean then
            if game.Workspace:FindFirstChild("world_assets").StaticObjects.Misc.TOSIC:FindFirstChild("Model") then
                game.Workspace:FindFirstChild("world_assets").StaticObjects.Misc.TOSIC.Model.Parent = game.StarterPack
            for i,v in pairs(game.Workspace:FindFirstChild("world_assets").StaticObjects.Misc.TOSIC:GetChildren()) do
                v.Parent = game.StarterPack
            end
        end
        else
            if game.StarterPack:FindFirstChild("Model") then
            game.StarterPack.Model.Parent = game.Workspace:FindFirstChild("world_assets").StaticObjects.Misc.TOSIC
            for i,v in pairs(game.StarterPack:GetChildren()) do
                v.Parent = game.Workspace:FindFirstChild("world_assets").StaticObjects.Misc.TOSIC
            end
            end
        end
    else return end
    end
}

local sky = game.Lighting:FindFirstChild("Sky")
sec3:Dropdown{ name="Skybox", content={"Galaxy","Island","Purple Sky","Forest","City","Minecraft"}, default="", callback=function(v)
    if sky then
    if v == "Galaxy" then
        sky.SkyboxBk = "rbxassetid://1138550863"
        sky.SkyboxDn = "rbxassetid://1138551165"
        sky.SkyboxFt = "rbxassetid://1138552163"
        sky.SkyboxLf = "rbxassetid://1138551555"
        sky.SkyboxRt = "rbxassetid://1138552890"
        sky.SkyboxUp = "rbxassetid://153520294"
    elseif v == "Island" then
        sky.SkyboxBk = "http://www.roblox.com/asset/?id=14753804949"
        sky.SkyboxDn = "http://www.roblox.com/asset/?id=14753795573"
        sky.SkyboxFt = "http://www.roblox.com/asset/?id=14753807625"
        sky.SkyboxLf = "http://www.roblox.com/asset/?id=14753797417"
        sky.SkyboxRt = "http://www.roblox.com/asset/?id=14753799966"
        sky.SkyboxUp = "http://www.roblox.com/asset/?id=14753810287"
    elseif v == "Purple Sky" then
        sky.SkyboxBk = "http://www.roblox.com/asset/?id=16553658937"
        sky.SkyboxDn = "http://www.roblox.com/asset/?id=16553660713"
        sky.SkyboxFt = "http://www.roblox.com/asset/?id=16553662144"
        sky.SkyboxLf = "http://www.roblox.com/asset/?id=16553664042"
        sky.SkyboxRt = "http://www.roblox.com/asset/?id=16553665766"
        sky.SkyboxUp = "http://www.roblox.com/asset/?id=16553667750"
    elseif v == "Forest" then
        sky.SkyboxBk = "rbxassetid://17428978603"
        sky.SkyboxDn = "rbxassetid://17428977445"
        sky.SkyboxFt = "rbxassetid://17428977114"
        sky.SkyboxLf = "rbxassetid://17428978399"
        sky.SkyboxRt = "rbxassetid://17428976828"
        sky.SkyboxUp = "rbxassetid://17428976669"
    elseif v == "City" then
        sky.SkyboxBk = "http://www.roblox.com/asset/?id=10345426"
        sky.SkyboxDn = "http://www.roblox.com/asset/?id=10345444"
        sky.SkyboxFt = "http://www.roblox.com/asset/?id=10345426"
        sky.SkyboxLf = "http://www.roblox.com/asset/?id=10345426"
        sky.SkyboxRt = "http://www.roblox.com/asset/?id=10345426"
        sky.SkyboxUp = "http://www.roblox.com/asset/?id=10345487"
    elseif v == "Minecraft" then
        sky.SkyboxBk = "http://www.roblox.com/asset/?id=3754796725"
        sky.SkyboxDn = "http://www.roblox.com/asset/?id=3754833439"
        sky.SkyboxFt = "http://www.roblox.com/asset/?id=3754795891"
        sky.SkyboxLf = "http://www.roblox.com/asset/?id=3754798649"
        sky.SkyboxRt = "http://www.roblox.com/asset/?id=3754799327"
        sky.SkyboxUp = "http://www.roblox.com/asset/?id=3754888841"
    end
else
    local newsky = Instance.new("Sky")
    newsky.Parent = game.Lighting
end
end}

getgenv().grassdisabled = false
sec3:Toggle{
    name = "No Grass",
    callback = function(Boolean)
        if getgenv().grassdisabled == false then

local terrain = Workspace:WaitForChild("Terrain", 10)


local CLEAR_RADIUS = 512
local VERTICAL_EXT  = 128
local INTERVAL     = 5
local lastTime     = 0

local function clearGrassAt(position)
    local minV = position - Vector3.new(CLEAR_RADIUS, VERTICAL_EXT, CLEAR_RADIUS)
    local maxV = position + Vector3.new(CLEAR_RADIUS, VERTICAL_EXT, CLEAR_RADIUS)
    local region = Region3.new(minV, maxV):ExpandToGrid(4)
    terrain:ReplaceMaterial(region, 4, Enum.Material.Grass, Enum.Material.LeafyGrass)
end

if Workspace.CurrentCamera then
    clearGrassAt(Workspace.CurrentCamera.CFrame.Position)
end

RunService.Heartbeat:Connect(function(dt)
    lastTime = lastTime + dt
    if lastTime < INTERVAL then return end
    lastTime = 0

    local cam = Workspace.CurrentCamera
    if cam then
        clearGrassAt(cam.CFrame.Position)

    end
end)
getgenv().grassdisabled = true
else
    return
end
    end
}

sec3:Button{name = "No Impact Damage", callback = function() 
    for _, v in pairs(game.Workspace:GetChildren()) do
        if v.Name == "WorldModel" and v:IsA("Model") then
            for _, k in pairs(v:GetDescendants()) do
                if k.Name == "Impact" and k:IsA("RemoteEvent") then
                    k:Destroy()
                end
            end
        end
    end
end}

----------------------------------------------------------------------VISUALS---------------------------------------------------------------

local sec4 = tab2:Section{
    Side = "Left",
    Name = "Player ESP"
}



--// =========================================================
--// PLAYER ESP - workspace.Characters (UID-based)
--// =========================================================

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local localPlayer = Players.LocalPlayer

-- Đảm bảo thư mục Characters tồn tại
local CharactersFolder = workspace:FindFirstChild("Characters")
if not CharactersFolder then
    warn("[ESP] workspace.Characters không tồn tại! Script sẽ không chạy đúng.")
    CharactersFolder = Instance.new("Folder")
    CharactersFolder.Name = "Characters"
    CharactersFolder.Parent = workspace
end

--// UI SECTION (cần có tab2 từ UI lib của bạn)
local sec4 = sec4 or (tab2 and tab2:Section{Side = "Left", Name = "Player ESP"}) -- fallback nếu bạn đã tạo sec4 trước đó

--// SQUAD TRACKING -----------------------------------------------------------
local squadMembers = {}  -- [playerName or displayName] = true

local function updateSquadMembers()
    squadMembers = {}

    local pg = localPlayer:FindFirstChild("PlayerGui")
    if not pg then return end

    -- Chuỗi deep FindFirstChild an toàn
    local function safeFind(obj, childName)
        return obj and obj:FindFirstChild(childName) or nil
    end

    local wrapper = safeFind(
        safeFind(
            safeFind(
                safeFind(
                    safeFind(
                        safeFind(
                            safeFind(pg, "GameUI"),
                        "Menu"),
                    "Squad"),
                "SquadPage"),
            "Squad"),
        "Squad"),
    "Wrapper")

    if not wrapper then return end

    for _, v in pairs(wrapper:GetDescendants()) do
        if v:IsA("TextLabel") and v.Name == "Label" then
            local txt = v.Text
            if txt ~= "DISBAND" and txt ~= "LEAVE" and txt ~= "" then
                squadMembers[txt] = true
            end
        end
    end
end

task.spawn(function()
    while true do
        updateSquadMembers()
        task.wait(2)
    end
end)

--// ESP SETTINGS ------------------------------------------------------------
local espSettings = {
    showBoxes = false,
    filledBoxes = false,
    boxTransparency = 0.5,
    boxThickness = 2,
    boxColor = Color3.fromRGB(255, 255, 255),

    showNames = false,
    nameTextSize = 14,
    nameOutlines = false,
    nameColor = Color3.fromRGB(255, 255, 255),

    showDistance = false,
    distanceTextSize = 16,
    distanceOutlines = false,
    distanceColor = Color3.fromRGB(255, 255, 255),
    distanceUnits = "Studs",

    hideteammates = false,
    ignoreLocal = true, -- tự ẩn bản thân
}

-- UI bindings
if sec4 then
    sec4:Toggle{ name="ESP Boxes", callback=function(v) espSettings.showBoxes = v end }
    sec4:Toggle{ name="Filled Boxes", callback=function(v) espSettings.filledBoxes = v end }
    sec4:Slider{ name="Box Transparency", min=0, max=100, default=100, callback=function(v) espSettings.boxTransparency = v / 100 end }
    sec4:Slider{ name="Box Thickness", min=0, max=100, default=1, callback=function(v) espSettings.boxThickness = v end }
    sec4:Colorpicker{ name="Box Color", default=Color3.fromRGB(255,255,255), callback=function(c) espSettings.boxColor = c end }

    sec4:Toggle{ name="Player Names", callback=function(v) espSettings.showNames = v end }
    sec4:Slider{ name="Name Text Size", min=0, max=100, default=14, callback=function(v) espSettings.nameTextSize = v end }
    sec4:Toggle{ name="Name Outlines", callback=function(v) espSettings.nameOutlines = v end }
    sec4:Colorpicker{ name="Name Color", default=Color3.fromRGB(255,255,255), callback=function(c) espSettings.nameColor = c end }

    sec4:Toggle{ name="Distance Display", callback=function(v) espSettings.showDistance = v end }
    sec4:Slider{ name="Distance Text Size", min=0, max=100, default=16, callback=function(v) espSettings.distanceTextSize = v end }
    sec4:Toggle{ name="Distance Outlines", callback=function(v) espSettings.distanceOutlines = v end }
    sec4:Colorpicker{ name="Distance Color", default=Color3.fromRGB(255,255,255), callback=function(c) espSettings.distanceColor = c end }
    sec4:Dropdown{ name="Distance Units", content={"Meters","Studs","Feet","Yards","Inches","Kilometers"}, default="Studs", callback=function(v) espSettings.distanceUnits = v end }
    sec4:Toggle{ name="Ignore Teammates", callback=function(v) espSettings.hideteammates = v end }
end

--// UNIT CONVERSION ---------------------------------------------------------
local function convertDistance(studs, unit)
    local conversions = {
        Studs = studs,
        Meters = studs * 0.28,
        Feet = studs * 0.9186,
        Yards = studs * 0.3062,
        Inches = studs * 11.0236,
        Kilometers = studs * 0.00028,
    }
    return conversions[unit] or studs
end

--// ESP OBJECT CREATION / MGMT -----------------------------------------------
local function createESP()
    return {
        box = Drawing.new("Square"),
        name = Drawing.new("Text"),
        distance = Drawing.new("Text"),
    }
end

local function hideESP(esp)
    for _, obj in pairs(esp) do
        obj.Visible = false
    end
end

local function clearESP(esp)
    for _, obj in pairs(esp) do
        if obj and obj.Remove then
            obj:Remove()
        end
    end
end

--// DISPLAY NAME RESOLUTION --------------------------------------------------
-- Trả về tên hiển thị dùng để so teammate + label
local function getNameForCharacter(character)
    -- Ưu tiên Humanoid.DisplayName nếu có
    local hum = character:FindFirstChildWhichIsA("Humanoid")
    if hum then
        local dn = hum.DisplayName
        if type(dn) == "string" and dn ~= "" then
            return dn
        end
    end
    -- Check Attribute "PlayerName"
    local attr = character:GetAttribute("PlayerName")
    if type(attr) == "string" and attr ~= "" then
        return attr
    end
    -- fallback UID
    return character.Name
end

-- Lấy UID của localPlayer (nếu có character trong folder)
local LOCAL_UID = nil
do
    for _, ch in ipairs(CharactersFolder:GetChildren()) do
        local n = getNameForCharacter(ch)
        if n == localPlayer.Name or n == localPlayer.DisplayName then
            LOCAL_UID = ch.Name
            break
        end
    end
end

-- Khi CharactersFolder thay đổi, thử cập nhật LOCAL_UID
CharactersFolder.ChildAdded:Connect(function(ch)
    task.defer(function()
        local n = getNameForCharacter(ch)
        if n == localPlayer.Name or n == localPlayer.DisplayName then
            LOCAL_UID = ch.Name
        end
    end)
end)
CharactersFolder.ChildRemoved:Connect(function(ch)
    if LOCAL_UID == ch.Name then
        LOCAL_UID = nil
    end
end)

--// ESP STATE TABLE ----------------------------------------------------------
-- Key = UID (character.Name)
local espObjects = {}

local function getESP(uid)
    local obj = espObjects[uid]
    if not obj then
        obj = createESP()
        espObjects[uid] = obj
    end
    return obj
end

--// CORE UPDATE LOOP ---------------------------------------------------------
RunService.RenderStepped:Connect(function()
    -- Cập nhật / vẽ ESP cho tất cả character hiện có
    for _, character in ipairs(CharactersFolder:GetChildren()) do
        local uid = character.Name
        local esp = getESP(uid)

        -- Ẩn bản thân nếu ignoreLocal
        if espSettings.ignoreLocal and LOCAL_UID and uid == LOCAL_UID then
            hideESP(esp)
            continue
        end

        local nameForDisplay = getNameForCharacter(character)

        -- Ẩn teammate nếu bật tùy chọn
        if espSettings.hideteammates and squadMembers[nameForDisplay] then
            hideESP(esp)
            continue
        end

        -- Part refs
        local head = character:FindFirstChild("Head") or character:FindFirstChild("ServerColliderHead")
        local hrp  = character:FindFirstChild("HumanoidRootPart")

        if not head or not hrp then
            hideESP(esp)
            continue
        end

        -- Project to screen
        local headPos, onScreen1 = camera:WorldToViewportPoint(head.Position)
        local footPos, onScreen2 = camera:WorldToViewportPoint(hrp.Position)
        if not (onScreen1 and onScreen2) then
            hideESP(esp)
            continue
        end

        -- Box dims
        local height = math.abs(footPos.Y - headPos.Y)
        local width = height / 2
        local x = footPos.X - width / 2
        local y = headPos.Y

        -- Box
        esp.box.Size = Vector2.new(width, height)
        esp.box.Position = Vector2.new(x, y)
        esp.box.Color = espSettings.boxColor
        esp.box.Filled = espSettings.filledBoxes
        esp.box.Thickness = espSettings.boxThickness
        esp.box.Transparency = espSettings.boxTransparency
        esp.box.Visible = espSettings.showBoxes

        -- Name
        esp.name.Text = nameForDisplay
        esp.name.Position = Vector2.new(x + width / 2, y - 16)
        esp.name.Size = espSettings.nameTextSize
        esp.name.Center = true
        esp.name.Outline = espSettings.nameOutlines
        esp.name.Color = espSettings.nameColor
        esp.name.Visible = espSettings.showNames

        -- Distance
        local dist = (camera.CFrame.Position - hrp.Position).Magnitude
        local converted = convertDistance(dist, espSettings.distanceUnits)
        esp.distance.Text = string.format("%.1f %s", converted, espSettings.distanceUnits)
        esp.distance.Position = Vector2.new(x + width / 2, y + height + 2)
        esp.distance.Size = espSettings.distanceTextSize
        esp.distance.Center = true
        esp.distance.Outline = espSettings.distanceOutlines
        esp.distance.Color = espSettings.distanceColor
        esp.distance.Visible = espSettings.showDistance
    end

    -- Ẩn ESP cho UID đã rời
    for uid, esp in pairs(espObjects) do
        if not CharactersFolder:FindFirstChild(uid) then
            hideESP(esp)
        end
    end
end)

--// CLEANUP API (tuỳ chọn, gọi khi unload script)
local function DestroyAllESP()
    for uid, esp in pairs(espObjects) do
        clearESP(esp)
        espObjects[uid] = nil
    end
end

local sec5 = tab2:Section{
    Side = "Middle",
    Name = "Object ESP"
}

local vehicleESP = {
    Enabled = false,
    ShowDistance = false,
    Outline = false,
    Size = 14,
    Color = Color3.new(1, 1, 1),
    ActiveDrawings = {}
}

local function createVehicleDrawing(chassis)
    local drawing = Drawing.new("Text")
    drawing.Visible = false
    drawing.Center = true
    drawing.Outline = vehicleESP.Outline
    drawing.Font = 2
    drawing.Color = vehicleESP.Color
    drawing.Size = vehicleESP.Size
    vehicleESP.ActiveDrawings[chassis] = drawing
    return drawing
end

local function updateVehicles()
    for chassis, drawing in pairs(vehicleESP.ActiveDrawings) do
        if chassis.Parent then
            local pos, onScreen = camera:WorldToViewportPoint(chassis.Position)
            if onScreen then
                drawing.Position = Vector2.new(pos.X, pos.Y)
                drawing.Text = vehicleESP.ShowDistance and 
                    string.format("Vehicle (%d)", (chassis.Position - LocalPlayer.Character.PrimaryPart.Position).Magnitude) 
                    or "Vehicle"
                drawing.Visible = vehicleESP.Enabled
            else
                drawing.Visible = false
            end
        else
            drawing:Remove()
            vehicleESP.ActiveDrawings[chassis] = nil
        end
    end
end

local function vehicleScanner()
    for _, obj in pairs(workspace:GetChildren()) do
        if obj:FindFirstChild("Chassis") and not vehicleESP.ActiveDrawings[obj.Chassis] then
            createVehicleDrawing(obj.Chassis)
        end
    end
end

local vehicleConnections = {}
local function manageVehicleESP()
    if vehicleESP.Enabled then
        vehicleConnections.render = RunService.RenderStepped:Connect(updateVehicles)
        vehicleConnections.scan = RunService.Heartbeat:Connect(vehicleScanner)
        vehicleConnections.added = workspace.ChildAdded:Connect(function(child)
            if child:FindFirstChild("Chassis") then
                createVehicleDrawing(child.Chassis)
            end
        end)
    else
        for _, conn in pairs(vehicleConnections) do
            conn:Disconnect()
        end
        for _, drawing in pairs(vehicleESP.ActiveDrawings) do
            drawing:Remove()
        end
        vehicleESP.ActiveDrawings = {}
    end
end

local settings = {
    show = true,
    outline = true,
    showDistance = false,
    size = 14,
    color = Color3.fromRGB(255, 255, 255),
}

local drawings = {}


local function createText(part)
    local text = Drawing.new("Text")
    text.Center = true
    text.Outline = settings.outline
    text.Size = settings.size
    text.Text = "Beartrap"
    text.Color = settings.color
    text.Visible = settings.show

    return {
        text = text,
        update = function()
            if part and part:IsDescendantOf(workspace) then
                local pos, onScreen = camera:WorldToViewportPoint(part.Position)
                text.Position = Vector2.new(pos.X, pos.Y)
                if settings.showDistance then
                    local dist = (camera.CFrame.Position - part.Position).Magnitude
                    text.Text = "Beartrap [" .. math.floor(dist) .. "m]"
                else
                    text.Text = "Beartrap"
                end
                text.Size = settings.size
                text.Outline = settings.outline
                text.Color = settings.color
                text.Visible = onScreen and settings.show
            else
                text.Visible = false
            end
        end,
        destroy = function()
            text:Remove()
        end
    }
end

runservice.RenderStepped:Connect(function()
    local found = {}

    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model.Name == "Beartrap" then
            local main = model:FindFirstChild("Main")
            if main and main:IsA("BasePart") then
                found[main] = true
                if not drawings[main] then
                    drawings[main] = createText(main)
                end
            end
        end
    end

    for part, data in pairs(drawings) do
        if found[part] and part:IsDescendantOf(workspace) then
            data.update()
        else
            data.destroy()
            drawings[part] = nil
        end
    end
end)



local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera

local showGraves = false
local showDistance = false
local showOutlines = false
local graveSize = 14
local graveColor = Color3.fromRGB(255, 255, 255)

local graveESP = {}

local function createGraveESP(model, meshPart)
    local text = Drawing.new("Text")
    text.Size = graveSize
    text.Center = true
    text.Outline = showOutlines
    text.Color = graveColor
    text.Visible = showGraves

    graveESP[model] = { text = text, part = meshPart }
end

local function removeGraveESP(model)
    if graveESP[model] then
        graveESP[model].text:Remove()
        graveESP[model] = nil
    end
end

RunService.RenderStepped:Connect(function()
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model.Name == "Default" and not graveESP[model] then
            local meshPart = model:FindFirstChildWhichIsA("MeshPart")
            if meshPart then
                createGraveESP(model, meshPart)
            end
        end
    end

    for model, data in pairs(graveESP) do
    if not model:IsDescendantOf(workspace) or not data.part then
        removeGraveESP(model)
    else
        local screenPos, onScreen = camera:WorldToViewportPoint(data.part.Position)
        if onScreen and showGraves then
            local name = data.part:GetAttribute("DisplayName") or "Unknown"
            local searched = data.part:GetAttribute("Searched")
            local distanceStr = ""

            if typeof(searched) == "boolean" and searched == true then
                name = "[Searched] " .. name
            end

            if showDistance then
                local dist = (camera.CFrame.Position - data.part.Position).Magnitude
                distanceStr = string.format(" [%.1fm]", dist)
            end

            data.text.Text = name .. distanceStr
            data.text.Position = Vector2.new(screenPos.X, screenPos.Y)
            data.text.Size = graveSize
            data.text.Color = graveColor
            data.text.Outline = showOutlines
            data.text.Visible = true
        else
            data.text.Visible = false
        end
    end
end

end)

---------------


sec5:Toggle{
    name = "Show Vehicles",
    callback = function(bool)
        vehicleESP.Enabled = bool
        manageVehicleESP()
    end
}

sec5:Toggle{
    name = "Show Beartrap",
    callback = function(bool)
        settings.show = bool
        for _, d in pairs(drawings) do
            d.text.Visible = bool
        end
    end
}

sec5:Toggle{
    name = "Show Graves",
    callback = function(bool)
        showGraves = bool
        for _, v in pairs(graveESP) do
            v.text.Visible = bool
        end
    end
}


sec5:Label("Outline")

sec5:Toggle{
    name = "Vehicle Outlines",
    callback = function(bool)
        vehicleESP.Outline = bool
        for _, drawing in pairs(vehicleESP.ActiveDrawings) do
            drawing.Outline = bool
        end
    end
}

sec5:Toggle{
    name = "Beartrap Outlines",
    callback = function(bool)
        settings.outline = bool
        for _, d in pairs(drawings) do
            d.text.Outline = bool
        end
    end
}

sec5:Toggle{
    name = "Grave Outlines",
    callback = function(bool)
        showOutlines = bool
        for _, v in pairs(graveESP) do
            v.text.Outline = bool
        end
    end
}


sec5:Label("Distance")

sec5:Toggle{
    name = "Show Vehicle Distance",
    callback = function(bool)
        vehicleESP.ShowDistance = bool
    end
}

sec5:Toggle{
    name = "Show Beartrap Distance",
    callback = function(bool)
        settings.showDistance = bool
    end
}

sec5:Toggle{
    name = "Show Grave Distance",
    callback = function(bool)
        showDistance = bool
    end
}



sec5:Label("Size")

sec5:Slider{
    name = "Vehicle Size",
    min = 0,
    max = 100,
    default = 14,
    callback = function(value)
        vehicleESP.Size = value
        for _, drawing in pairs(vehicleESP.ActiveDrawings) do
            drawing.Size = value
        end
    end
}

sec5:Slider{
    name = "Beartrap Size",
    min = 0,
    max = 100,
    default = 14,
    callback = function(value)
        settings.size = value
        for _, d in pairs(drawings) do
            d.text.Size = value
        end
    end
}

sec5:Slider{
    name = "Grave Size",
    min = 0,
    max = 100,
    default = 14,
    callback = function(value)
        graveSize = value
        for _, v in pairs(graveESP) do
            v.text.Size = value
        end
    end
}



sec5:Label("Color")

sec5:Colorpicker{
    name = "Vehicle Color", 
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        vehicleESP.Color = color
        for _, drawing in pairs(vehicleESP.ActiveDrawings) do
            drawing.Color = color
        end
    end
}

sec5:Colorpicker{
    name = "Beartrap Color", 
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        settings.color = color
        for _, d in pairs(drawings) do
            d.text.Color = color
        end
    end
}

sec5:Colorpicker{
    name = "Grave Color", 
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        graveColor = color
        for _, v in pairs(graveESP) do
            v.text.Color = color
        end
    end
}




local sec6 = tab2:Section{
    Side = "Right",
    Name = "Inventory Viewer"
}

local UserInputService = game:GetService("UserInputService")

inventoryEnabled = false
fovEnabled       = false
snaplineEnabled  = false
showAmmo         = false
showMuzzle       = false
showReticle      = false
showOthers       = false

fovRadius         = 100
fovThickness      = 2
snaplineThickness = 1

fovColor        = Color3.new(1,1,1)
snaplineColor   = Color3.new(1,1,1)
fovRainbow      = false
snaplineRainbow = false

local adSDK1w430ofASK = Instance.new("ScreenGui")
local b1w0OVCMzax12FKdx = Instance.new("Frame")
local Fkz2104DKSaMCZ94Qq = Instance.new("TextLabel")
local cmA192xzcqkdMZCvvb = Instance.new("TextLabel")
local Dk102qsdmzxFAKscv192 = Instance.new("TextLabel")
local _10cvfxsmQWEKfmxzv = Instance.new("TextLabel")
local vmA10cmaqdkVMaq02143 = Instance.new("TextLabel")
local OOAmc129fkSAqwqeqd1924 = Instance.new("TextLabel")
local fmv103qKDq1024mbxz = Instance.new("TextLabel")
local wwqf123459QASFIAqw014vksdmA = Instance.new("UICorner")
local borkf120fmczqkeQEQsaffkqwDA192 = Instance.new("UIStroke")
local bkamfmwqkeqwkk142190519fsafmvzxqd = Instance.new("UIScale")


adSDK1w430ofASK.Name = "adSDK1w430ofASK"
adSDK1w430ofASK.Parent = game.CoreGui
adSDK1w430ofASK.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

bkamfmwqkeqwkk142190519fsafmvzxqd.Name= "bkamfmwqkeqwkk142190519fsafmvzxqd"

b1w0OVCMzax12FKdx.Name = "b1w0OVCMzax12FKdx"
b1w0OVCMzax12FKdx.Parent = adSDK1w430ofASK
b1w0OVCMzax12FKdx.BackgroundColor3 = Color3.new(0.0784314, 0.0980392, 0.117647)
b1w0OVCMzax12FKdx.BorderColor3 = Color3.new(0, 0, 0)
b1w0OVCMzax12FKdx.BorderSizePixel = 0
b1w0OVCMzax12FKdx.Position = UDim2.new(0.033147417, 0, 0.0247260295, 0)
b1w0OVCMzax12FKdx.Size = UDim2.new(0, 380, 0, 250)

borkf120fmczqkeQEQsaffkqwDA192.Parent = b1w0OVCMzax12FKdx
borkf120fmczqkeQEQsaffkqwDA192.Color = Color3.fromRGB(180, 180, 190)
borkf120fmczqkeQEQsaffkqwDA192.Thickness = 2
borkf120fmczqkeQEQsaffkqwDA192.Transparency = 0.3

Fkz2104DKSaMCZ94Qq.Name = "Fkz2104DKSaMCZ94Qq"
Fkz2104DKSaMCZ94Qq.Parent = b1w0OVCMzax12FKdx
Fkz2104DKSaMCZ94Qq.BackgroundColor3 = Color3.new(1, 1, 1)
Fkz2104DKSaMCZ94Qq.BackgroundTransparency = 1
Fkz2104DKSaMCZ94Qq.BorderColor3 = Color3.new(0, 0, 0)
Fkz2104DKSaMCZ94Qq.BorderSizePixel = 0
Fkz2104DKSaMCZ94Qq.Position = UDim2.new(0, 0, 0.0480000004, 0)
Fkz2104DKSaMCZ94Qq.Size = UDim2.new(0, 380, 0, 30)
Fkz2104DKSaMCZ94Qq.Font = Enum.Font.SourceSans
Fkz2104DKSaMCZ94Qq.Text = "No Target"
Fkz2104DKSaMCZ94Qq.TextColor3 = Color3.new(1, 1, 0.627451)
Fkz2104DKSaMCZ94Qq.TextSize = 18
Fkz2104DKSaMCZ94Qq.TextWrapped = true

cmA192xzcqkdMZCvvb.Name = "cmA192xzcqkdMZCvvb"
cmA192xzcqkdMZCvvb.Parent = b1w0OVCMzax12FKdx
cmA192xzcqkdMZCvvb.BackgroundColor3 = Color3.new(1, 1, 1)
cmA192xzcqkdMZCvvb.BackgroundTransparency = 1
cmA192xzcqkdMZCvvb.BorderColor3 = Color3.new(0, 0, 0)
cmA192xzcqkdMZCvvb.BorderSizePixel = 0
cmA192xzcqkdMZCvvb.Position = UDim2.new(0, 0, 0.215000004, 0)
cmA192xzcqkdMZCvvb.Size = UDim2.new(0, 380, 0, 30)
cmA192xzcqkdMZCvvb.Font = Enum.Font.SourceSans
cmA192xzcqkdMZCvvb.Text = "No Target"
cmA192xzcqkdMZCvvb.TextColor3 = Color3.new(0.784314, 0.392157, 1)
cmA192xzcqkdMZCvvb.TextSize = 16
cmA192xzcqkdMZCvvb.TextWrapped = true

Dk102qsdmzxFAKscv192.Name = "Dk102qsdmzxFAKscv192"
Dk102qsdmzxFAKscv192.Parent = b1w0OVCMzax12FKdx
Dk102qsdmzxFAKscv192.BackgroundColor3 = Color3.new(1, 1, 1)
Dk102qsdmzxFAKscv192.BackgroundTransparency = 1
Dk102qsdmzxFAKscv192.BorderColor3 = Color3.new(0, 0, 0)
Dk102qsdmzxFAKscv192.BorderSizePixel = 0
Dk102qsdmzxFAKscv192.Position = UDim2.new(0, 0, 0.36500001, 0)
Dk102qsdmzxFAKscv192.Size = UDim2.new(0, 380, 0, 30)
Dk102qsdmzxFAKscv192.Font = Enum.Font.SourceSans
Dk102qsdmzxFAKscv192.Text = "No Target"
Dk102qsdmzxFAKscv192.TextColor3 = Color3.new(1, 0.313726, 0.313726)
Dk102qsdmzxFAKscv192.TextSize = 16
Dk102qsdmzxFAKscv192.TextWrapped = true

_10cvfxsmQWEKfmxzv.Name = "10cvfxsmQWEKfmxzv"
_10cvfxsmQWEKfmxzv.Parent = b1w0OVCMzax12FKdx
_10cvfxsmQWEKfmxzv.BackgroundColor3 = Color3.new(1, 1, 1)
_10cvfxsmQWEKfmxzv.BackgroundTransparency = 1
_10cvfxsmQWEKfmxzv.BorderColor3 = Color3.new(0, 0, 0)
_10cvfxsmQWEKfmxzv.BorderSizePixel = 0
_10cvfxsmQWEKfmxzv.Position = UDim2.new(0, 0, 0.514999986, 0)
_10cvfxsmQWEKfmxzv.Size = UDim2.new(0, 380, 0, 30)
_10cvfxsmQWEKfmxzv.Font = Enum.Font.SourceSans
_10cvfxsmQWEKfmxzv.Text = "No Target"
_10cvfxsmQWEKfmxzv.TextColor3 = Color3.new(0.470588, 0.784314, 0.313726)
_10cvfxsmQWEKfmxzv.TextSize = 16
_10cvfxsmQWEKfmxzv.TextWrapped = true

vmA10cmaqdkVMaq02143.Name = "vmA10cmaqdkVMaq02143"
vmA10cmaqdkVMaq02143.Parent = b1w0OVCMzax12FKdx
vmA10cmaqdkVMaq02143.BackgroundColor3 = Color3.new(1, 1, 1)
vmA10cmaqdkVMaq02143.BackgroundTransparency = 1
vmA10cmaqdkVMaq02143.BorderColor3 = Color3.new(0, 0, 0)
vmA10cmaqdkVMaq02143.BorderSizePixel = 0
vmA10cmaqdkVMaq02143.Position = UDim2.new(0, 0, 0.665000021, 0)
vmA10cmaqdkVMaq02143.Size = UDim2.new(0, 380, 0, 30)
vmA10cmaqdkVMaq02143.Font = Enum.Font.SourceSans
vmA10cmaqdkVMaq02143.Text = "No Target"
vmA10cmaqdkVMaq02143.TextColor3 = Color3.new(1, 0.705882, 0.235294)
vmA10cmaqdkVMaq02143.TextSize = 16
vmA10cmaqdkVMaq02143.TextWrapped = true

bkamfmwqkeqwkk142190519fsafmvzxqd.Scale = 1

OOAmc129fkSAqwqeqd1924.Name = "OOAmc129fkSAqwqeqd1924"
OOAmc129fkSAqwqeqd1924.Parent = b1w0OVCMzax12FKdx
OOAmc129fkSAqwqeqd1924.BackgroundColor3 = Color3.new(1, 1, 1)
OOAmc129fkSAqwqeqd1924.BackgroundTransparency = 1
OOAmc129fkSAqwqeqd1924.BorderColor3 = Color3.new(0, 0, 0)
OOAmc129fkSAqwqeqd1924.BorderSizePixel = 0
OOAmc129fkSAqwqeqd1924.Position = UDim2.new(0, 0, 0.845000029, 0)
OOAmc129fkSAqwqeqd1924.Size = UDim2.new(0, 380, 0, 30)
OOAmc129fkSAqwqeqd1924.Font = Enum.Font.SourceSans
OOAmc129fkSAqwqeqd1924.Text = "No Target"
OOAmc129fkSAqwqeqd1924.TextColor3 = Color3.new(0.392157, 0.784314, 1)
OOAmc129fkSAqwqeqd1924.TextSize = 16
OOAmc129fkSAqwqeqd1924.TextWrapped = true

fmv103qKDq1024mbxz.Name = "fmv103qKDq1024mbxz"
fmv103qKDq1024mbxz.Parent = b1w0OVCMzax12FKdx
fmv103qKDq1024mbxz.BackgroundColor3 = Color3.new(1, 1, 1)
fmv103qKDq1024mbxz.BorderColor3 = Color3.new(0, 0, 0)
fmv103qKDq1024mbxz.BorderSizePixel = 0
fmv103qKDq1024mbxz.Position = UDim2.new(0, 0, 0.192000002, 0)
fmv103qKDq1024mbxz.Size = UDim2.new(0, 380, 0, 1)
fmv103qKDq1024mbxz.Font = Enum.Font.SourceSans
fmv103qKDq1024mbxz.Text = ""
fmv103qKDq1024mbxz.TextColor3 = Color3.new(0, 0, 0)
fmv103qKDq1024mbxz.TextSize = 14

wwqf123459QASFIAqw014vksdmA.Name = "wwqf123459QASFIAqw014vksdmA"
wwqf123459QASFIAqw014vksdmA.Parent = b1w0OVCMzax12FKdx

invviewerteamcheck = false

background = b1w0OVCMzax12FKdx
background.Active = true
background.Draggable = true
background.Selectable = true

local scaler = bkamfmwqkeqwkk142190519fsafmvzxqd

scaler.Parent = background

local inviewer = adSDK1w430ofASK
inviewer.Enabled = inventoryEnabled

local name = Fkz2104DKSaMCZ94Qq
gun1 = cmA192xzcqkdMZCvvb
gun2 = Dk102qsdmzxFAKscv192
gun3 = _10cvfxsmQWEKfmxzv
gun4 = vmA10cmaqdkVMaq02143
local others = OOAmc129fkSAqwqeqd1924

local fovCircle = Drawing.new("Circle")
fovCircle.Visible      = fovEnabled
fovCircle.Thickness    = fovThickness
fovCircle.Filled       = false
fovCircle.Radius       = fovRadius
fovCircle.Transparency = 1
fovCircle.Color        = fovColor


snapLine.Visible      = snaplineEnabled
snapLine.Thickness    = snaplineThickness
snapLine.Transparency = 1
snapLine.Color        = snaplineColor

local function formatInventory(slot)
    if not slot or not slot.Value then return "None" end

    local gun = slot.Value
    local parts = {gun.Name}

    if showAmmo then
        local m = slot:FindFirstChild("BulletsInMagazine")
        local r = slot:FindFirstChild("BulletsInReserve")
        if m and r then
            table.insert(parts, "["..m.Value.."/"..r.Value.."]")
        end
    end

    local atts = {}
    if showMuzzle then
        local mu = slot:FindFirstChild("AttachmentMuzzle")
        if mu and mu.Value then table.insert(atts, mu.Value.Name) end
    end
    if showReticle then
        local re = slot:FindFirstChild("AttachmentReticle")
        if re and re.Value then table.insert(atts, re.Value.Name) end
    end
    if #atts > 0 then
        table.insert(parts, "("..table.concat(atts,", ")..")")
    end

    return table.concat(parts, " ")
end

RunService.RenderStepped:Connect(function()
    local mousePos = UserInputService:GetMouseLocation()

    local squadmates = {}
    local squadUI = LocalPlayer:FindFirstChild("PlayerGui")
        and LocalPlayer.PlayerGui:FindFirstChild("GameUI")
        and LocalPlayer.PlayerGui.GameUI:FindFirstChild("Menu")
        and LocalPlayer.PlayerGui.GameUI.Menu:FindFirstChild("Squad")
    if squadUI then
        local wrapper = squadUI.SquadPage.Squad.Squad.Wrapper
        for _, v in pairs(wrapper:GetDescendants()) do
            if v:IsA("TextLabel") and v.Name == "Label" then
                if v.Text ~= "DISBAND" and v.Text ~= "LEAVE" then
                    squadmates[v.Text] = true
                end
            end
        end
    end

    fovCircle.Visible   = fovEnabled
    fovCircle.Radius    = fovRadius
    fovCircle.Thickness = fovThickness
    fovCircle.Position  = mousePos
    fovCircle.Color     = fovRainbow and Color3.fromHSV(tick()%5/5,1,1) or fovColor

    local candidates = {}
    if invviewerteamcheck then
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and not squadmates[plr.Name] and plr.Character then
            local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local sp, on = Camera:WorldToViewportPoint(hrp.Position)
                if on then
                    local sv = Vector2.new(sp.X, sp.Y)
                    local dist = (sv - mousePos).Magnitude
                    if dist <= fovRadius then
                        table.insert(candidates, {player = plr, screen = sv, dist = dist})
                    end
                end
            end
        end
    end
else
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local sp, on = Camera:WorldToViewportPoint(hrp.Position)
                if on then
                    local sv = Vector2.new(sp.X, sp.Y)
                    local dist = (sv - mousePos).Magnitude
                    if dist <= fovRadius then
                        table.insert(candidates, {player = plr, screen = sv, dist = dist})
                    end
                end
            end
        end
    end
end
    table.sort(candidates, function(a, b) return a.dist < b.dist end)
    local targ = candidates[1]

    snapLine.Visible   = snaplineEnabled and targ ~= nil
    snapLine.From      = mousePos
    snapLine.To        = targ and targ.screen or Vector2.new(0, 0)
    snapLine.Thickness = snaplineThickness
    snapLine.Color     = snaplineRainbow and Color3.fromHSV(tick()%5/5,1,1) or snaplineColor

    inviewer.Enabled = inventoryEnabled
    if inventoryEnabled and targ then
        local p = targ.player
        name.Text = p.Name.."'s Inventory"

        local inv = p:FindFirstChild("GunInventory")
        local otherSVs, fistsSVs = {}, {}
        if inv then
            for _, s in ipairs(inv:GetChildren()) do
                if s:IsA("ObjectValue") and s.Value then
                    if s.Value.Name == "Fists" then
                        table.insert(fistsSVs, s)
                    else
                        table.insert(otherSVs, s)
                    end
                end
            end
        end

        local slots = {}
        for _, s in ipairs(otherSVs) do table.insert(slots, s) end
        for _, s in ipairs(fistsSVs) do table.insert(slots, s) end

        gun1.Text = formatInventory(slots[1])
        gun2.Text = formatInventory(slots[2])
        gun3.Text = formatInventory(slots[3])
        gun4.Text = formatInventory(slots[4])

        if showOthers then
            local attrs = {}
            for _, attrName in ipairs({"EquipmentBackpack","EquipmentPants","EquipmentShirt"}) do
                local raw = p:GetAttribute(attrName)
                if raw then
                    local item = raw:match('ClassName"%s*:%s*"([^%.]+)%.item')
                    if item then
                        table.insert(attrs, item)
                    end
                end
            end
            others.Text = (#attrs > 0) and table.concat(attrs, ", ") or "None"
        else
            others.Text = ""
        end
    else
        name.Text = "No target"
        gun1.Text = "None"
        gun2.Text = "None"
        gun3.Text = "None"
        gun4.Text = "None"
        others.Text = ""
    end
end)



sec6:Toggle{
    name    = "Enable Inventory Viewer",
    default = false,
    callback= function(v)
        inventoryEnabled = v
        inviewer.Enabled = v
    end
}
sec6:Toggle{
    name    = "Show FOV Circle",
    callback= function(v) fovEnabled = v end
}
sec6:Toggle{
    name    = "Show Snapline",
    callback= function(v) snaplineEnabled = v end
}
sec6:Slider{
    name    = "FOV Radius",
    min     = 0, max = 500, default = fovRadius,
    callback= function(v) fovRadius = v end
}
sec6:Slider{
    name    = "FOV Outline Thickness",
    min     = 0, max = 100, default = fovThickness,
    callback= function(v) fovThickness = v end
}
sec6:Slider{
    name    = "Snapline Thickness",
    min     = 0, max = 100, default = snaplineThickness,
    callback= function(v) snaplineThickness = v end
}
sec6:Colorpicker{
    name    = "FOV Circle Color",
    default = Color3.fromRGB(255,255,255),
    callback= function(c) fovColor = c end
}
sec6:Toggle{
    name    = "FOV Rainbow Effect",
    callback= function(v) fovRainbow = v end
}
sec6:Colorpicker{
    name    = "Snapline Color",
    default = Color3.fromRGB(255,255,255),
    callback= function(c) snaplineColor = c end
}
sec6:Toggle{
    name    = "Snapline Rainbow Effect",
    callback= function(v) snaplineRainbow = v end
}

sec6:Label("Customizations")
sec6:Toggle{
    name    = "Show Ammo",
    callback= function(v) showAmmo = v end
}

sec6:Toggle{
    name    = "Show Muzzle",
    callback= function(v) showMuzzle = v end
}

sec6:Toggle{
    name    = "Show Reticle",
    callback= function(v) showReticle = v end 
}

sec6:Toggle{
    name    = "Show Others",
    callback= function(v) showOthers = v end
}

sec6:Slider{
    name    = "Background Size",
    min     = 0, max = 200, default = 100,
    callback= function(v) scaler.Scale = v/100 end
}

sec6:Toggle{
    name    = "Ignore Teammates",
    callback= function(v) invviewerteamcheck = v end
}


local sec7 = tab3:Section{
    Side = "Left",
    Name = "Ammo ESP"
}

local replicated_storage = game:GetService("ReplicatedStorage")

local misc_folder = workspace.world_assets.StaticObjects.Misc
local ammo_folder = replicated_storage.Assets.ViewModels.Combat.Ammo

show_ammo = false
ammo_outline = true
ammo_size = 14
ammo_color = Color3.fromRGB(255, 255, 255)
show_distance = false
render_distance = 1000

local esp_table = {}

local function extract_id(str)
    if type(str) ~= "string" then
        return tostring(str)
    end
    local id = str:match("(%d+)")
    return id or str
end

local function apply_settings_to_drawing(txt)
    if not txt then return end
    txt.Outline = ammo_outline
    txt.Size = ammo_size
    txt.Color = ammo_color
end

local function update_existing_esp_settings()
    for source_part, data in pairs(esp_table) do
        local txt = data.drawing
        if txt and txt.Visible then
            apply_settings_to_drawing(txt)
        end
    end
end

local function create_esp_on_source(source_part, ammo_label)
    if not show_ammo then
        return
    end

    local success, Drawing = pcall(function() return Drawing end)
    if not success or typeof(Drawing) ~= "table" or not Drawing.new then
        return
    end

    if esp_table[source_part] then
        return
    end

    local txt = Drawing.new("Text")
    txt.Center = true
    txt.Visible = true
    txt.Text = ammo_label
    apply_settings_to_drawing(txt)

    esp_table[source_part] = {
        drawing = txt,
        label = ammo_label,
    }

    update_existing_esp_settings()
end

local function clear_all_esp()
    for source_part, data in pairs(esp_table) do
        if data.drawing and data.drawing.Remove then
            data.drawing:Remove()
        end
    end
    table.clear(esp_table)
end

local function scan_for_matches()
    if not show_ammo then
        return
    end

    if not misc_folder then
        return
    end
    if not ammo_folder then
        return
    end

    for _, misc_child in ipairs(misc_folder:GetChildren()) do
        if misc_child:IsA("Model") then
            local source = misc_child:FindFirstChild("Main")
            if source and source:IsA("MeshPart") then
                local src_mesh_id = extract_id(source.MeshId)
                local src_tex_id  = extract_id(source.TextureID)
                for _, ammo_model in ipairs(ammo_folder:GetChildren()) do
                    if ammo_model:IsA("Model") and ammo_model.Name ~= "Model" then
                        local ammo_main = ammo_model:FindFirstChild("Main")
                        if ammo_main and ammo_main:IsA("MeshPart") then
                            local ammo_mesh_id = extract_id(ammo_main.MeshId)
                            local ammo_tex_id  = extract_id(ammo_main.TextureID)
                            if ammo_mesh_id == src_mesh_id and ammo_tex_id == src_tex_id then
                                create_esp_on_source(source, ammo_model.Name)
                            end
                        end
                    end
                end
            end
        end
    end
end

local function cleanup_removed()
    for source_part, data in pairs(esp_table) do
        local drawing_text = data.drawing
        if not source_part.Parent then
            drawing_text:Remove()
            esp_table[source_part] = nil
        end
    end
end

runservice.RenderStepped:Connect(function()
    if not show_ammo or not camera then return end

    local cam_pos = camera.CFrame.Position

    for source_part, data in pairs(esp_table) do
        local drawing_text = data.drawing

        if not source_part.Parent then
            drawing_text:Remove()
            esp_table[source_part] = nil
        else
            local dist = (source_part.Position - cam_pos).Magnitude

            if dist > render_distance then
                drawing_text.Visible = false
            else
                apply_settings_to_drawing(drawing_text)

                if show_distance then
                    drawing_text.Text = data.label .. " [" .. tostring(math.floor(dist)) .. "m]"
                else
                    drawing_text.Text = data.label
                end

                local screen_pos, on_screen = camera:WorldToViewportPoint(source_part.Position)
                if on_screen then
                    drawing_text.Position = Vector2.new(screen_pos.X, screen_pos.Y)
                    drawing_text.Visible = true
                else
                    drawing_text.Visible = false
                end
            end
        end
    end
end)

if misc_folder then
    misc_folder.ChildAdded:Connect(function()
        task.defer(scan_for_matches)
    end)
end
if ammo_folder then
    ammo_folder.ChildAdded:Connect(function()
        task.defer(scan_for_matches)
    end)
end

runservice.Heartbeat:Connect(cleanup_removed)

sec7:Toggle{
    name = "Show Ammo",
    callback = function(v)
        show_ammo = v
        if show_ammo then
            scan_for_matches()
        else
            clear_all_esp()
        end
    end
}

sec7:Toggle{
    name = "Ammo Outline",
    callback = function(v)
        ammo_outline = v
        update_existing_esp_settings()
    end
}

sec7:Slider{
    name = "Ammo Size",
    min = 0, max = 100, default = 14,
    callback = function(v)
        ammo_size = v
        update_existing_esp_settings()
    end
}

sec7:Colorpicker{
    name = "Ammo Color",
    default = Color3.fromRGB(255,255,255),
    callback = function(c)
        ammo_color = c
        update_existing_esp_settings()
    end
}

sec7:Toggle{
    name = "Show Distance",
    callback = function(v)
        show_distance = v
        if camera then
            local cam_pos = camera.CFrame.Position
            for source_part, data in pairs(esp_table) do
                if data.drawing then
                    if show_distance then
                        local dist = math.floor((source_part.Position - cam_pos).Magnitude)
                        data.drawing.Text = data.label .. " [" .. tostring(dist) .. "m]"
                    else
                        data.drawing.Text = data.label
                    end
                end
            end
        end
    end
}

sec7:Slider{
    name = "Render Distance",
    min = 0, max = 1000, default = 500,
    callback = function(v)
        render_distance = v
    end
}

local sec8 = tab3:Section{
    Side = "Middle",
    Name = "Weapon ESP"
}

local miscFolder      = workspace.world_assets.StaticObjects.Misc
local gunDataFolder   = game:GetService("ReplicatedStorage").GunData

local meleeBlacklist = {
    AxeFire = true, ChemLight = true, Cleaver = true, CombatKnife = true,
    Crowbar = true, HandSaw = true, Shovel = true, KitchenKnife = true,
    GrenadeSmokeMakeshift = true, GrenadeSmoke = true, AxeMakeshift = true,
    Cuffs = true, Fists = true, GenericItemThrow = true, Generic_consumable = true,
    GrenadeFrag = true, GrenadeGas = true, GrenadeMolotov = true,
    GrenadePipebomb = true, Snowball = true, ThrowableBottle = true,
    Wrench = true, SteakKnife = true,
}

espEnabled   = false
espSize      = 14
espOutline   = false
espColor     = Color3.fromRGB(255, 255, 255)
excludeMelee = false
showDistance = false
renderRange  = 500

local function getMeshPartsInfo(model)
    local info = {}
    for _, child in ipairs(model:GetChildren()) do
        if child:IsA("MeshPart") then
            local cNames = {}
            for _, c in ipairs(child:GetChildren()) do
                table.insert(cNames, c.Name)
            end
            table.sort(cNames)
            table.insert(info, { Name = child.Name, MeshId = child.MeshId, ChildrenNames = cNames })
        end
    end
    table.sort(info, function(a,b) return a.Name < b.Name end)
    return info
end

local function meshPartsMatch(a, b)
    if #a ~= #b then return false end
    for i = 1, #a do
        if a[i].Name ~= b[i].Name or a[i].MeshId ~= b[i].MeshId then
            return false
        end
        local c1, c2 = a[i].ChildrenNames, b[i].ChildrenNames
        if #c1 ~= #c2 then return false end
        for j = 1, #c1 do
            if c1[j] ~= c2[j] then return false end
        end
    end
    return true
end

local function getChildrenNames(model)
    local names = {}
    for _, c in ipairs(model:GetChildren()) do
        table.insert(names, c.Name)
    end
    table.sort(names)
    return names
end

local function childrenNamesMatch(a, b)
    if #a ~= #b then return false end
    for i = 1, #a do
        if a[i] ~= b[i] then return false end
    end
    return true
end

local function getDescendantsNames(model)
    local names = {}
    for _, d in ipairs(model:GetDescendants()) do
        table.insert(names, d.Name)
    end
    table.sort(names)
    return names
end

local function descendantsNamesMatch(a, b)
    if #a ~= #b then return false end
    for i = 1, #a do
        if a[i] ~= b[i] then return false end
    end
    return true
end

local gunDataMeshInfos = {}
for _, folder in ipairs(gunDataFolder:GetChildren()) do
    local wm = folder:FindFirstChild("WorldModel")
    if wm then
        gunDataMeshInfos[folder.Name] = getMeshPartsInfo(wm)
    end
end

local espStore = {}

local function createESP(model, gunName)
    local handle = model:FindFirstChild("Handle")
    if not (handle and handle:IsA("BasePart")) then return end
    if espStore[model] then return end

    local text = Drawing.new("Text")
    text.Size         = espSize
    text.Color        = espColor
    text.Center       = true
    text.Outline      = espOutline
    text.OutlineColor = Color3.new(0, 0, 0)

    local conn
    conn = RunService.RenderStepped:Connect(function()
        if not espEnabled or not handle.Parent or not model.Parent then
            text.Visible = false
            text:Remove()
            espStore[model] = nil
            conn:Disconnect()
            return
        end

        local camPos = camera.CFrame.Position
        local dist   = (handle.Position - camPos).Magnitude
        local pos, onScreen = camera:WorldToViewportPoint(handle.Position)

        if onScreen and dist <= renderRange then
            if showDistance then
                text.Text = string.format("%s [%d]", gunName, math.floor(dist))
            else
                text.Text = gunName
            end
            text.Position = Vector2.new(pos.X, pos.Y)
            text.Visible  = true
        else
            text.Visible = false
        end
    end)

    espStore[model] = {
        drawing    = text,
        connection = conn,
        name       = gunName,
    }
end

local function checkModelAgainstGunData(model)
    if not model:IsA("Model") then return nil end
    local meshInfo = getMeshPartsInfo(model)
    if #meshInfo > 0 then
        for name, refInfo in pairs(gunDataMeshInfos) do
            if meshPartsMatch(meshInfo, refInfo) then
                return name
            end
        end
    else
        local childNames = getChildrenNames(model)
        local candidates = {}
        for name, _ in pairs(gunDataMeshInfos) do
            local gd = gunDataFolder:FindFirstChild(name)
            if gd and gd:FindFirstChild("WorldModel") then
                if childrenNamesMatch(childNames, getChildrenNames(gd.WorldModel)) then
                    table.insert(candidates, name)
                end
            end
        end
        if #candidates == 1 then
            return candidates[1]
        elseif #candidates > 1 then
            local descNames = getDescendantsNames(model)
            for _, name in ipairs(candidates) do
                if descendantsNamesMatch(descNames, getDescendantsNames(gunDataFolder[name].WorldModel)) then
                    return name
                end
            end
        end
    end
    return nil
end

local function checkAndCreateESPForModel(model)
    local gunName = checkModelAgainstGunData(model)
    if gunName then
        if excludeMelee and meleeBlacklist[gunName] then return end
        createESP(model, gunName)
    end
end

local function initialScan()
    for _, model in ipairs(miscFolder:GetChildren()) do
        checkAndCreateESPForModel(model)
    end
end

miscFolder.ChildAdded:Connect(function(newModel)
    wait(0.1)
    checkAndCreateESPForModel(newModel)
end)

sec8:Toggle{
    name    = "Show Weapons",
    default = espEnabled,
    callback = function(v)
        espEnabled = v
        if not v then
            for _, d in pairs(espStore) do d.drawing.Visible = false end
        else
            initialScan()
        end
    end
}
sec8:Slider{
    name    = "Weapon Size",
    min     = 0, max = 100, default = espSize,
    callback = function(v)
        espSize = v
        for _, d in pairs(espStore) do d.drawing.Size = v end
    end
}
sec8:Toggle{
    name    = "Weapon Outlines",
    default = espOutline,
    callback = function(v)
        espOutline = v
        for _, d in pairs(espStore) do d.drawing.Outline = v end
    end
}
sec8:Colorpicker{
    name    = "Weapon Color",
    default = espColor,
    callback = function(c)
        espColor = c
        for _, d in pairs(espStore) do d.drawing.Color = c end
    end
}
sec8:Toggle{
    name    = "Show Distance",
    default = showDistance,
    callback = function(v)
        showDistance = v
    end
}
sec8:Toggle{
    name    = "Exclude Melee",
    default = excludeMelee,
    callback = function(v)
        excludeMelee = v
        if v then
            for model, data in pairs(espStore) do
                if meleeBlacklist[data.name] then
                    data.drawing:Remove()
                    data.connection:Disconnect()
                    espStore[model] = nil
                end
            end
        else
            initialScan()
        end
    end
}
sec8:Slider{
    name    = "Render Distance",
    min     = 0, max = 1000, default = renderRange,
    callback = function(v)
        renderRange = v
    end
}

initialScan()


library:Init()
